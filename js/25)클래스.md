# 25. 클래스

클래스를 표현식으로 정의할 수 있다는 것은 클래스가 값으로 사용할 수 있는 일급 객체라는 것을 의미한다

클래스도 프로토타입을 가지고 있다 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재하기 때문이다

클래스 몸체에서 정의할 수 있는 메서드는 constructor(생성자), 프로토타입 메서드, 정적 메서드의 세가지가 있다

클래스는 반드시 new와 함께 호출해야한다

클래스는 함수 표현식과 같이 기명함수로 사용하여도 함수이름은 내부에서만 사용이 가능하다

constructor은 인스턴스를 생성하고 초기화 하기 위한 특수한 메서드로 이름을 변경할 수 없다

constructor는 메서드로 해석되는 것이 아니라 클래스가 평가되어 생성한 함수 객체 코드의 일부가 된다 즉 클래스 정의가 평가되면 constructor의 기술된 동작을 하는 함수 객체가 생성된다

constructor는 2개 시상 포함하면 문법 에러가 발생하며 생략할 수는 있다

constructor문 안에는 return문을 반드시 생략하여야한다 return문에는 암묵적으로 this를 반환하고 있기 때문이다 이는 생성자 함수 또한 같다

정적 메서드는 인스턴스를 생성하지 않아도 호출할 수 있는 메서드를 말한다

정적 메서드는 프로토타입 체인 상에는 클래스가 존재하지 않기 떄문에 인스턴스로 클래스의 메서드를 상속받을 수없고 호출 할 수 없다

정적 메서드(static)와 프로토타입 메서드는 this의 사용방식에 따라 다르다 정적 메서드는 클래스명으로 호출을 하는데 프로토타입 메서드는 인스턴스 객체의 명으로 호출을 한다 이는 프로토타입 메서드는 인스턴스로 호출해야 하므로 프로토타입 내부의 this는 프로토타입 메서드를 호출한 인스턴스를 가리킨다 정적 메서드는 클래스로 호출해야 하므로 정적 메서드 내부의 this는 인스턴스가 아닌 클래스를 가리킨다

이는 정적 메서드는 전역에서 사용하기 좋다는 것을 의미한다 즉 구조화할 때 유용하다

클래스 필드(멤버 변수) 정의  제안으로 인해 인스턴스 프로퍼티를 정의하는 방식은 두 가지가 되었다
외부 초기값으로 클래스 필드를 초기화할 필요가 있다면 constructor에서 인스턴스 프로퍼티를 정의하는 기존방식

외부 초기값으로 클래스필드를 초기화할 필요가 없다면 기존 constructor에서 인스턴스 프로퍼티를 정의하는 방식과 클래스 필드 정의 제안 모두 사용할 수 있다

밑에 두개는 버전에 따라 사용 가능한지 확인이 필요하다

#을 클래스 필드 앞에 붙이면 private 필드를 정의 할 수 있다

static으로 정적 필드를 정의 할 수 있다

extends 키워드는 클래스뿐만 아니라 생성자 함수를 상속받아 클래스를 확장할 수 도 있다. 키워드 앞에는 반드시 클래스가 와야한다

서브클래스에서 constructor를 생략하면 암묵적으로 constructor(… args) { super(…args); }가 선언된다 수퍼클래스의  constructor을 명시적으로 서브 클래스에서 사용하려면 super 호출을 통헤 전달된다

서브클래스에서 constructor을 생략하지 않을 경우 반드시 super를 호출해야한다

서브클래스의 constructor에서 spuer를 호출하기 전에는 this를 참조할 수 없다

super는 반드시 서브클래스의 constructor에서만 호출한다

super 메서드 축약 표현으로만 정의된 함수만이 [[HomeObject]]를 갖는다

상속 관계도 프로토타 체인으로 묶여있다

자바스크립트 엔진은 클래스를 평가할 때 수퍼클래스와 서브클래스를 구분하기위해 내부 슬롯 [[ConstrucrtorKind]]를 갖는데 다은 클래스를 상속받지 않는 클래스는 base로 설정되지만 다른 클래스를 상속받는 서브클래스는 내부 슬롯이 derived로 설정된다

서브클래스는 자신이 직접 인스턴스를 생성하지 않고 수퍼클래스에게 인스턴스 생성을 위힘할 수 있다 이것이 바로 서브클래스의 constructor에서 반드시 super를 호출해야 하는 이유이다

상속클래스의 동작순서

1.  서브클래스의 super호출
2. 수퍼클래스의 인스턴스 생성과 this 바인딩
3. 수퍼클래스의 인스턴스 초기화
4. 서브클래스 constructor로 복귀와 this 바인딩
5. 서브클래스의 인스턴스 초기화
6. 인스턴스 반환

extends는 [[Construct]] 내부 메서드를 갖는 함수 객체로 평가될 수 있는 모든 표현식에서 사용가능하다

소감 : 클래스 또함 객체로 프로토타입 기반으로 이루어져 있다 상속을 하더라도 프로토타입 기반으로 클래스끼리 프로토타입 체인이 묶여있고 클래스 프로토타입 또한 체인으로 묶여있다 extends는 [[Construct]]가 있는 함수 객체로 평가될 수 있는 모든 표현식에서 사용이 가능하다 클래스 내부에는 프로토타입 메서드와 constructer메서드 정적 메서드가 3개가 존재할 수 있다 생성자 함수도 동일하게 존재할 수 있지만 클래스는 new를 통하여 constructer의 this를 바인딩 해주어야한다 constructer를 작성하지 않으면 암묵적으로 생성한다 서브 클래스는 super를 먼저 작성해주어야하며 return은 작성해서는 안된다