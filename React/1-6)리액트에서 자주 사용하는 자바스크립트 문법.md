# 1. 리액트 개발을 위해 꼭 알아야하는 자바스크립트(1-6)

## 1-6 리액트에서 자주 사용하는 자바스크립트 문법

JSX 구문 내부에서 객체를 조작하거나 객체의 얕은 동등 비교 문제를 피하기 위해 객체 분해 할당을 하는 등 리액트의 몇 가지 독특한 특징에서 비롯된다.

ECMAScript의 버전을 지원하는 브라우저의 버전을 고려하며 사용자에 따라 다양한 브라우저를 사용하기에 이를 염두하고 문법을 작성하여야한다.

바벨은 자바스크립트의 최신 문법을 다양한 브라우저에서도 일관적으로 지원할 수 있도록 코드를 트랜스파일한다.

익스플로러 11이 지원이 끝났음에도 버전업을 못하는 경우나 엣지로 접근이 가능하기에 ES5(익스플로러가 지원하는 범위는 ES5이다)로 트렌스파일된 코드를 파악하는 것이 중요하다.

### 구조 분해 할당

배열 또는 객체의 값을 분해해 개별 변수에 즉시 할당하는 것을 의미한다.

- 배열 구조 분해 할당 - ES6
- 객체 구조 분해 할당 - ECMA 2018

**배열 구조 분해 할당(리액트에서는 useState등에서 자주 사용된다)**

객체 구조 분해 할당은 이름 변경이 번거롭지만 배열 구조 분해 할당은 자유롭다.

배열의 구조 분해 할당은 ,의 위치에 따라 값이 결정된다.

배열의 길이가 작을 때 주로 쓰인다.

배열의 구조 분해 할당에는 기본값을 선언할 수 있다. 이때 반드시 undefined일때만 기본값이 설정된다.

특정값 이후의 값을 다시금 배열로 선언하고 싶다면 전개 연산자(spread 연산자)인 …을 사용할 수 있다. … 을 사용하면 나머지 모든 값을 해당 변수에 배열로 넣게 된다. 이는 예측이 가능한 뒤쪽에서만 사용이 가능하다.

**객체** 구**조 분해 할당(리액트에서는 props를 바로 꺼낼 때 등 자주 사용된다)**

객체는 배열의 구조 분해와 달리 객체 내부 이름으로 꺼내온다는 차이가 있다.

```jsx
const object = {
	a: 1,
	b: 2,
}

const {a: first, b: second} = object
//first: 1
//second: 2
```

위와 같이 새로운 이름으로 할당 또한 가능하다.

```jsx
const object = {
	a: 1,
	b: 1,
}

const {a= 10, b= 10, c= 10} = object
//a: 1
//b: 2
//c: 10
```

위와 같이 기본 값을 주는 것도 가능하다.

- :  이름 변경 시 사용
- = 값 변경 시 사용

```jsx
const key = 'a'
const object = {
	a: 1,
	b: 1,
}

const {[key]: a} = object
```

변수에 있는 값으로 꺼내오는 계산된 속성 이름 방식도 가능하다. 이때 반드시 객체의 네이밍과 같은 네이밍이 필요하다.

… 연산자는 배열 구조 분해 할당과 같이 뒤쪽에서만 이루어져야 한다.

배열과 다르게 트렌스파일을 할 경우 번들링 크기가 상대적으로 크기 떄문에 ES5을 지원하여야 한다면 사용을 고려해보아야 한다.

### 전개 구문(spread 연산자[…])

**배열의 전개 구문**

```jsx
const arr1 = ['a', 'b']
const arr2 = [...arr1, 'c', 'd', 'e'] //['a', 'b', 'c', 'd', 'e']
```

…배열을 사용하면 해당 배열을 마치 전개하는 것처럼 선언하고, 이를 내부 배열에서 활용 할 수 있다. 이러한 특징을 활용하면 기존 배열에 영향을 미치지 배열을 복사하는 것도 가능하다 즉 부수 효과가 없다.

**객체의 전개 구문**

객체 또한 객체를 합성할 때 편리함을 주지만 객체는 작동의 순서 차이로 인해 전혀 다른 객체가 생성될 수 있다.

```jsx
const obj = {
	a: 1,
	b: 1,
	c: 1,
	d: 1,
	e: 1,
}

const aObj = {
	...obj,
	c: 10,
}  //{a: 1, b: 1, c: 10, d: 1, e: 1}

const bObj = {
	c: 10,
	...obj,
}  //{a: 1, b: 1, c: 10, d: 1, e: 1}
```

aObj는 전개 구문 이후 값 할당이 이루어지며 전개 구문 할당 값을 덮어 쓰지만

bObj는 값 할당 이후 전개 구문이 이루어지며 전개 구문 할당이 값을 덮어 쓴다.

이러한 차이가 순서에 중요한 역할을 한다.

전개 구문 또한 구조 분해 할당과 같이 트렌스파일을 할 때 크기가 상대적으로 크기에 ES5를 지원한다면 사용을 고려해 보아야 한다.

### 객체 초기자

객체를 선언할 때 객체에 넣고자 하는 키와 값을 가지고 있는 변수가 이미 존재한다면 해당 값을 간결하게 넣어줄 수 있는 방식이다.

```jsx
const a = 1
const b = 2

const obj = {
	a,
	b,
}

//{a: 1, b: 2}
```

트렌스파일 이후에도 큰 부담이 없이 없다.

### Array 프로토타입의 메서드: map, filter, reduce, forEach

JSX 내부에서 배열을 조작해 바로 원하는 JSX를 반환하는 특성상 위 메서드는 자주 쓰인다. 이 메서드들은 기존 배열의 값을 건들지 않고 새로은 값을 만들어 내기 때문에 기존 값이 변경될 염려 없이 안전하게 사용할 수 있다. 또한 ES5에서 사용하는 문법으로 트렌스파일 부담이 없다.

**Array.prototype.map**

Array.prototype.map은 인수로 전달받은 배열과 똑같은 길이의 새로운 배열을 반환하는 메서드다. 배열의 각 아이템을 순회하면서 각 아이템을 콜백으로 연산한 결과로 구성된 새로운 배열을 만들 수 있다. 리액트에서는 주로 특정 배열을 기반으로 어떠한 리액트 요소를 반환하고자 할 때 많이 사용한다

```jsx
const arr = [1,2,3,4,5]
const Elements = arr.map((item) => {
	return <Fragment key={item}>{item}</Fragment>
})
```

**Array.prototype.filter**

기존 배열에 대해 어떠한 조건을 만족하는 새로운 배열을 반환할 때 쓰인다.

```jsx
const arr = [1,2,3,4,5]
const evenArr = arr.filter((item) => item % 2 === 0)
// [2,4]
```

**Array.prototype.reduce**

```jsx
const arr = [1,2,3,4,5]
const sum = arr.reduce((result, item) => {
	return result + item
},0)
```

0은 reduce의 결과를 누적할 초기값이다. 그리고 reducer 콜백 함수의 첫 번째 인수는 앞서 선언한 초깃값의 현재값을 의미하고, 두번째 인수는 현재 배열의 아이템을 의미한다. 이 콜백의 반환값을 계속해서 초깃값에 누적하면서 새로운 값을 만든다고 볼 수 있다.

filter와 map의 두가지를 동시에 사용할 때를 reduce를 사용하여 작성할 수 있지만 코드의 가독성이 복잡하여 짧은 코드는 filter와 map을 동시에 활용하는 편이 좋지만 배열을 두 번 순회하는 문제가 있으므로 상황에 맞게 선택하면 좋다.

**Array.prototype.forEach**

콜백 함수를 받아 배열을 순회하면서 단순히 그 콜백 함수를 실행하기만 하는 메서드다

forEach는 아무런 반환값이 없다. 단순히 콜백 함수를 실행할 뿐 map과 같이 결과를 반환하는 작업은 수행하지 않는다. forEach는 에러를 던지지 않는 이상 내부에서 break,와 return 그 무엇을 이용해도 멈출 수 없다

forEach를 사용할 떄는 절대로 중간에 순회를 멈출 수 없다는 사실을 인지하고 있어야 한다.

### 삼항 조건 연산자

`조건문 ? 참일_때_값 : 거짓일_때_값`을 통하여 if문을 간단하게 쓸 수 있다는 점에서 리액트에서 자주 쓰이는데,특히 JSX 내부에서 조건부로 렌더링하기 위해서 가장 널리 쓰이는 방법이다.

하지만 편리함이 주는 이점 때문에 삼항 조건 연산자 내부에 또다시 삼항 연산자를 중첩해서 쓰는 경우가 발생하지만 이는 예측이 어렵기 때문에 가급적이면 쓰지 않는게 좋다.

### 정리

최신 자바스크립트 코드에 관심이 많다면 ECMAScript의 신규 문법을 제안하는 저장소인 [https://github.com/tc39/proposals](https://github.com/tc39/proposals를) 를 방문해보자