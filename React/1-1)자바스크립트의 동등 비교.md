# 1. 리액트 개발을 위해 꼭 알아야하는 자바스크립트(1-1)

## 1.1 자바스크립트의 동등 비교

- 훅을 반복적으로 사용할때 의존성 배열에 대해 고민하여야한다.
- 리액트 컴포넌트의 렌더링이 일어나는 이유 중 하나가 바로 props의 동등 비교에 따라 결과다
이때 props의 동등 비교는 객체의 얕은 비교를 기반으로 이뤄지는데, 이 얕은 비교가 리액트에서 어떻게 작성하는지 이해하지 못하면 렌더링 최적화에 어려움을 겪을 가능성이 크다.
- 리액트 컴포넌트가 렌더링할지를 판단하는 방법, 변수나 함수의 메모이제이션 등 모든 작업은 자바스크립트의 동등 비교를 기반으로 한다.

---

## 자바스크립트의 동등 비교의 수행 방법

### 자바스크립트 데이터 타입

자바스크립트는 원시 타입과 객체 타입을 가지고있다.

**원시 타입**

원시 타입은 객체 타입이 아닌 모든 타입이며 매서드를 갖지 않는다. 총 7개의 원시 타입이 존재한다.

undefined: 선언후 값이 할당하지 않은 변수 또는 값이 주어지지 않은 인수에 자동으로 할당되는 값

null: 아직 값이 없거나 비어 있는 값을 표현할 때 사용

즉 undefined는 선언됐지만 할당되지 않은 값이고 null은 명시적으로 비어 있음을 나타내는 값이다

boolean: true와 false의 값만 존재한다 이때 이와 같이 취급하는 truthy와 falsy가 존재하는데 

falsy는 false, NaN, undefined, null, 0~0x0n, “”~``이 있고 이외에는 모두 truthy이다

빈 객체인 {}, []도 비어있지만 truthy이다

number: 모든 숫자 범위는 -(2^53 - 1) ~ 2^53 - 1까지이다. 또한 모든 진수는 10진수로 표현된다

bigInt: number의 범위 한계를 넘는 숫자, 끝에 n을 붙이거나 BinInt()를 사용하여 생성한다

string: 텍스트 타입의 데이터로 ‘’, “”, 문자열 리터럴인 ``으로 표기한다

자바스크립트의 문자열은 원시타입이므로 한번 정의되면 변경이 불가능하다

symbol: 중복되지 않는 어떠한 고유한 값을 나타낸다 심벌 생성시 반드시 Symbol()을 사용한다

**객체 타입**
객체 타입은 원시타입 외에 모든 것이다(배열, 함수, 정규식, 클래스 모두)

객체 타입은 참조를 전달하여 참조 타입이라고 불린다

### 값을 저장하는 방식의 차이

원시 타입과 객체 타입의 가장 큰 타이는 값을 저장하는 방식이고 이는 동등 비교를 할 때 차이를 만드는 원인이 된다

원시 타입은 불변의 형태의 값이 저장된다. 이 값은 변수 할당 시점에 메모리 영역을 차지하고 저장된다

객체는 프로퍼티를 삭제, 추가, 수정할 수 있으므로 변경 가능한 형태로 저장되며, 값을 복사하는 것이 아닌 참조를 전달한다

자바스크립트 개발자는 항상 객체 간에 비교가 발생하면, 이 객체 간의 비교는 우리가 이해하는 내부의 값이 같다 하더라도 결과는 대부분 true가 아닐 수 있다는 것을 인지해야 한다

### 자바스크립트의 또 다른 비교 공식, Object.is

==은 비교하는 데이터의 타입을 캐스팅함 즉 서로의 타입을 동일하게함

=== 은 ==을 보안함

object.is는 조금더 개발자가 기대하는 방식으로 비교하지만 이 또한 참조 타입은 ===와 같은 값을 내줌

### 리액트에서의 동등 비교

리액트에서 사용하는 동등 비교는 Object.is이다

리액트에서는 object.Is를 기반으로 동등 비교하는 shallowEqual이라는 함수를 만들어 사용한다

리액트는 object.Is로 먼저 비교를 수행후 이를 통과하지 못하면 즉 객체이면 객체간 얕은 비교를 한번 더 수행한다. 이때 객체간 얕은 비교는 첫 번째 깊이에 존재하는 값만 비교한다는 것을 의미한다.

이를 수행하는 이유로는 리액트에서 사용하는 JSX props는 객체이고 props는 첫 번째 깊이만 비교하기 때문이다

리액트는 props에서 꺼내온 값을 기준으로 렌더링을 수행하기 때문에 깊이가 2차이상으로 이루어진 객체를 전달한다면 렌더링이 예상치 못하게 작동한다는 것을 알아야한다.

즉 shallowEqual은 객체간 비교를 수행해서 렌더링을 방지해 준다

### 정리

자바스크립트의 객체 비교의 불완전성으로 인하여 리액트의 함수형 프로그래밍 모델도 언어적 한계를 뛰어넘을수 없어 얕은 비교만 사용해 비교를 수행해 필요한 기능을 구현한다

이 개념을 이해한다면 향후 함수형 컴포넌트에서 사용되는 훅의 의존성 배열의 비교, 렌더링 방지를 넘어선 useMemo와 useCallback의 필요성, 렌더링 최적화를 위해서 꼭 필요한 React.memo를 올바르게 작동시키기 위해 고려해야 할 것들을 쉽게 이해할 수 있을 것이다.