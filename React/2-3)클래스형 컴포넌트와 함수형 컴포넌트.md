# 2. 리액트 핵심 요소 깊게 살펴보기(2-3)

## 2-3 클래스형 컴포넌트와 함수형 컴포넌트

함수형 컴포넌트는 초기에는 무상태 함수형 컴포넌트라고 해서 별도의 상태 없이 단순히 어떠한 요소를 정적으로 렌더링하는 것이 목적이었다.

즉 이때는 별다른 생명주기 메서드나 상태가 필요 없이 render만 하는 경우에만 제한적으로 사용됐

훅이 등장한 이후 함수형 컴포넌트에서 상태나 생명주기 메서드 비슷한 작업을 흉내 낼수 있게 되자 함수형 컴포넌트 사용빈도가 올라갔다

### 클래스형 컴포넌트

**클래스형 컴포넌트의 생명주기 메서드**

1. 마운트: 컴포넌트가 생성되는 시점
2. 업데이트: 이미 생성된 컴포넌트의 내용이 변경 되는 시점
3. 언마운트: 컴포넌트가 더 이상 존재하지 않는 시점
- render()
    - 클래스 컴포넌트에서 유일하게 필수 값으로 항상 쓰인다
    - 마운트와 업데이트 과정에서 일어난다
    - render() 함수는 항상 순수해야 하며 부수 효과가 없어야 한다
        - 즉 같은입력값이 들어가면 항상 같은 결과물을 반환해야 한다
    - state를 변경하는일은 클래스형 컴포넌트의 메서드나 다른 생명주기 메서드 내부에서 발생해야한다
- componentDidMount()
    - 클래스형 컴포넌트가 마운트되고 준비가 됐다면 그다음으로 호출되는 생명주기 메서드이다
        - 마운트가 준비되는 즉시 실행된다
    - 함수 내부에서 상태 변경이 가능하다
        - 하지만 state를 다루는 것은 생성자에서 하는 것이 좋다
        - API 호출 후 업데이트, DOM에 의존적인 작업 등을 하기 위해서이지 그 외에는 자제하는 것이 좋다
- componentDidUpdate()
    - 컴포넌트 업데이트가 일어난 이후 바로 실행된다.
    - state나 props의 변화에 따라 DOM을 업데이트하는 등에 쓰인다
        - 적절한 조건문으로 감싸지 않으면 계속 호출되는 일이 발생할 수 있다
- componentWillUnmount()
    - 컴포넌트가 언마운트되거나 더 이상 사용되지 않기 직전에 호출된다.
    - 메모리 누수나 불필요한 작동을 막기 위한 클린업 함수를 호출하기 위한 최적의 위치
    - 이벤트를 지우거나, API 호출을 최소한거나, setInterval, setTimeout으로 생성된 타이머를 지우는등의 작업을 하는데 유용하다
- 등등등(shouldComponentUpdate(), static getDerivedStateFromProps(), getSnapShotBeforeUpdate(), getDerivedStateFormError(), componentDidCatch())

Component의 경우 버튼을 누르는 대로, state가 업데이트 되는 대로 겐더링이 일어나지만 PureComponent는 state값에 대해 얕은 비교를 수행해 결과가 다를 때만 렌더링을 수행한다

**클래스 컴포넌트의 한계**

- 데이터의 흐름을 추적하기 어렵다
- 애플리케이션 내부 로직의 재사용이 어렵다
- 기능이 많아질수록 컴포넌트의 크기가 커진다
- 클래스는 함수에 비해 상대적으로 어렵다
- 코드 크기를 최적화하기 어렵다
- 핫 리로딩을 하는 데 상대적으로 불리하다
    - 핫 리로딩이란 코드에 변경 사항이 발생했을 때 앱을 다시 시작하지 않고서도 해당 변경된 코드만 업데이트해 변경 사항을 빠르게 적용하는 기법이다

### 함수형 컴포넌트

render 내부에서 필요한 함수를 선언할 때 this 바인딩을 조심할 필요도 없으며, state는 객체가 아닌 각각의 원시값으로 관리되어 훨씬 사용하기 편리하다.

### 함수형 컴포넌트 vs. 클래스형 컴포넌트

**생명주기 메서드의 부재**

클래스형 컴포넌트의 생명주기 메서드가 함수형 컴포넌트에서는 존재하지 않는다

생명주기는 React.Component에서 오는 것이기 때문에 클래스형 컴포넌트가 아닌 이상 생명주기 메서드를 더는 사용할 수 없다.

함수현 컴포넌트는 useEffect 훅을 사용해 생명주기 메서드인 componentDidMount, componentDidUpdate, compoenentWillUnmount를 비슷하게 구현할 수 있다.

이는 비슷하다 이지 똑같다는 아니다

useEffect는 생명주기 메서드가 아닌 state를 활용해 동기적으로 부수 효과를 만드는 메커니즘이다.

**함수형 컴포넌트와 렌더링된 값**

함수형 컴포넌트는 렌더링된 값을 고정하고, 클래스형 컴포넌트는 그렇지 못한다

함수형 컴포넌트는 렌더링이 일어날 때마다 그 순간의 값인 props와 state를 기준으로 렌더링 된다.

- 함수형은 props를 인수로 받기에 컴포넌트는 그 값을 변경할 수 없고 해당 값 그래도 사용한다

클래스형 컴포넌트는 시간의 흐름에 따라 변화하는 this를 기준으로 렌더링이 일어난다

- this에 바인딩 된 변수를 사용하여 컴포넌트는 값을 변경이 가능하다

**클래스형 컴포넌트를 공부해야 할까?**

일부 클래스 컴포넌트의 메서드, 특히 자식 컴포넌트에서 발생하는 에러에 대한 처리는 클래스형 컴포넌트로만 가능하므로 에러 처리를 위해서라도 클래스형 컴포넌트에 대한 지식이 어느 정도 필요하다

### 정리

리액트가 어떠한 고민을 통해 발전했는지 이해하자